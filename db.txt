# !pip install langgraph langchain-core sqlalchemy

import sqlite3
from typing import TypedDict, Annotated, Literal
from langgraph.graph import StateGraph, END
from langchain_core.prompts import ChatPromptTemplate
from langchain_community.chat_models import ChatOllama

# ========== PROPER DATABASE HANDLING ==========
class DatabaseManager:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialize()
        return cls._instance
    
    def initialize(self):
        """Initialize database with connection pool"""
        self.conn = sqlite3.connect('telecom.db', timeout=20, check_same_thread=False)
        self.create_tables()
        self.seed_data()
    
    def create_tables(self):
        with self.conn:
            self.conn.execute('''
                CREATE TABLE IF NOT EXISTS orders (
                    order_id TEXT PRIMARY KEY,
                    customer_id TEXT,
                    activation_status TEXT,
                    esim_status TEXT,
                    switch_status TEXT,
                    issue_type TEXT
                )''')
            
            self.conn.execute('''
                CREATE TABLE IF NOT EXISTS fallouts (
                    fallout_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id TEXT,
                    resolution_type TEXT,
                    status TEXT,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
                )''')
    
    def seed_data(self):
        sample_orders = [
            ('ORD123', 'CUST001', 'not_sent', 'active', 'ok', 'activation_issue'),
            ('ORD456', 'CUST002', 'sent', 'failed', 'ok', 'esim_issue'),
            ('ORD789', 'CUST003', 'sent', 'active', 'error', 'switch_issue'),
            ('ORD999', 'CUST004', 'sent', 'active', 'ok', 'unknown_issue')
        ]
        
        with self.conn:
            self.conn.executemany('''
                INSERT OR IGNORE INTO orders 
                VALUES (?,?,?,?,?,?)
            ''', sample_orders)
    
    def get_cursor(self):
        """Get fresh cursor from persistent connection"""
        return self.conn.cursor()

# Initialize database singleton
db_manager = DatabaseManager()

# ========== TELECOM TOOLS WITH SAFE ACCESS ==========
class TelecomTools:
    @staticmethod
    def check_activation_status(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('SELECT activation_status FROM orders WHERE order_id = ?', (order_id,))
            return cursor.fetchone()[0]

    @staticmethod
    def mark_for_resubmission(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('UPDATE orders SET activation_status = "pending" WHERE order_id = ?', (order_id,))
            return f"Order {order_id} marked for resubmission"

    @staticmethod
    def check_esim_status(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('SELECT esim_status FROM orders WHERE order_id = ?', (order_id,))
            return cursor.fetchone()[0]

    @staticmethod
    def reprovision_esim(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('UPDATE orders SET esim_status = "reprovisioned" WHERE order_id = ?', (order_id,))
            return f"eSIM reprovisioned for {order_id}"

    @staticmethod
    def check_switch_status(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('SELECT switch_status FROM orders WHERE order_id = ?', (order_id,))
            return cursor.fetchone()[0]

    @staticmethod
    def reprovision_switch(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('UPDATE orders SET switch_status = "reconfigured" WHERE order_id = ?', (order_id,))
            return f"Switch reconfigured for {order_id}"

# ========== REST OF THE CODE REMAINS SAME AS BEFORE ==========
# [Include all the agent definitions, workflow setup, and test code from previous implementation]
# ...

# Test the workflow
def run_test(order_id):
    print(f"\nProcessing order {order_id}:")
    for step in app.stream({"order_id": order_id, "resolution": "", "next_step": ""}):
        for key, value in step.items():
            print(f"{key}: {value}")
    print("="*50)

# Test cases
run_test("ORD123")  # Should go to resubmission
run_test("ORD456")  # Should go to eSIM
run_test("ORD789")  # Should go to switch
run_test("ORD999")  # Should go to human


class TelecomTools:
    @staticmethod
    def get_full_status(order_id: str) -> dict:
        """Get comprehensive status of all components"""
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('''
                SELECT activation_status, esim_status, switch_status 
                FROM orders WHERE order_id = ?
            ''', (order_id,))
            result = cursor.fetchone()
            return {
                'activation': result[0],
                'esim': result[1],
                'switch': result[2]
            }

    # Keep existing methods and add this new one
    @staticmethod
    def check_activation_status(order_id: str) -> str:
        return TelecomTools.get_full_status(order_id)['activation']

    @staticmethod 
    def check_esim_status(order_id: str) -> str:
        return TelecomTools.get_full_status(order_id)['esim']

    @staticmethod
    def check_switch_status(order_id: str) -> str:
        return TelecomTools.get_full_status(order_id)['switch']

    # Rest of the existing methods remain the same...
