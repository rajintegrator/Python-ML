# !pip install langgraph langchain-core sqlalchemy

import sqlite3
from typing import TypedDict, Annotated, Literal
from langgraph.graph import StateGraph, END
from langchain_core.prompts import ChatPromptTemplate
from langchain_community.chat_models import ChatOllama

# ========== PROPER DATABASE HANDLING ==========
class DatabaseManager:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.initialize()
        return cls._instance
    
    def initialize(self):
        """Initialize database with connection pool"""
        self.conn = sqlite3.connect('telecom.db', timeout=20, check_same_thread=False)
        self.create_tables()
        self.seed_data()
    
    def create_tables(self):
        with self.conn:
            self.conn.execute('''
                CREATE TABLE IF NOT EXISTS orders (
                    order_id TEXT PRIMARY KEY,
                    customer_id TEXT,
                    activation_status TEXT,
                    esim_status TEXT,
                    switch_status TEXT,
                    issue_type TEXT
                )''')
            
            self.conn.execute('''
                CREATE TABLE IF NOT EXISTS fallouts (
                    fallout_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    order_id TEXT,
                    resolution_type TEXT,
                    status TEXT,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
                )''')
    
    def seed_data(self):
        sample_orders = [
            ('ORD123', 'CUST001', 'not_sent', 'active', 'ok', 'activation_issue'),
            ('ORD456', 'CUST002', 'sent', 'failed', 'ok', 'esim_issue'),
            ('ORD789', 'CUST003', 'sent', 'active', 'error', 'switch_issue'),
            ('ORD999', 'CUST004', 'sent', 'active', 'ok', 'unknown_issue')
        ]
        
        with self.conn:
            self.conn.executemany('''
                INSERT OR IGNORE INTO orders 
                VALUES (?,?,?,?,?,?)
            ''', sample_orders)
    
    def get_cursor(self):
        """Get fresh cursor from persistent connection"""
        return self.conn.cursor()

# Initialize database singleton
db_manager = DatabaseManager()

# ========== TELECOM TOOLS WITH SAFE ACCESS ==========
class TelecomTools:
    @staticmethod
    def check_activation_status(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('SELECT activation_status FROM orders WHERE order_id = ?', (order_id,))
            return cursor.fetchone()[0]

    @staticmethod
    def mark_for_resubmission(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('UPDATE orders SET activation_status = "pending" WHERE order_id = ?', (order_id,))
            return f"Order {order_id} marked for resubmission"

    @staticmethod
    def check_esim_status(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('SELECT esim_status FROM orders WHERE order_id = ?', (order_id,))
            return cursor.fetchone()[0]

    @staticmethod
    def reprovision_esim(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('UPDATE orders SET esim_status = "reprovisioned" WHERE order_id = ?', (order_id,))
            return f"eSIM reprovisioned for {order_id}"

    @staticmethod
    def check_switch_status(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('SELECT switch_status FROM orders WHERE order_id = ?', (order_id,))
            return cursor.fetchone()[0]

    @staticmethod
    def reprovision_switch(order_id: str) -> str:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('UPDATE orders SET switch_status = "reconfigured" WHERE order_id = ?', (order_id,))
            return f"Switch reconfigured for {order_id}"

# ========== REST OF THE CODE REMAINS SAME AS BEFORE ==========
# [Include all the agent definitions, workflow setup, and test code from previous implementation]
# ...

# Test the workflow
def run_test(order_id):
    print(f"\nProcessing order {order_id}:")
    for step in app.stream({"order_id": order_id, "resolution": "", "next_step": ""}):
        for key, value in step.items():
            print(f"{key}: {value}")
    print("="*50)

# Test cases
run_test("ORD123")  # Should go to resubmission
run_test("ORD456")  # Should go to eSIM
run_test("ORD789")  # Should go to switch
run_test("ORD999")  # Should go to human


class TelecomTools:
    @staticmethod
    def get_full_status(order_id: str) -> dict:
        """Get comprehensive status of all components"""
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('''
                SELECT activation_status, esim_status, switch_status 
                FROM orders WHERE order_id = ?
            ''', (order_id,))
            result = cursor.fetchone()
            return {
                'activation': result[0],
                'esim': result[1],
                'switch': result[2]
            }

    # Keep existing methods and add this new one
    @staticmethod
    def check_activation_status(order_id: str) -> str:
        return TelecomTools.get_full_status(order_id)['activation']

    @staticmethod 
    def check_esim_status(order_id: str) -> str:
        return TelecomTools.get_full_status(order_id)['esim']

    @staticmethod
    def check_switch_status(order_id: str) -> str:
        return TelecomTools.get_full_status(order_id)['switch']

    # Rest of the existing methods remain the same...

class TelecomTools:
    @staticmethod
    def log_fallout(order_id: str, resolution_type: str):
        """Log fallout in the database"""
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('''
                INSERT INTO fallouts 
                (order_id, resolution_type, status)
                VALUES (?, ?, 'open')
            ''', (order_id, resolution_type))

    # Rest of the existing methods remain the same...
    @staticmethod
    def get_full_status(order_id: str) -> dict:
        with db_manager.conn:
            cursor = db_manager.get_cursor()
            cursor.execute('''
                SELECT activation_status, esim_status, switch_status 
                FROM orders WHERE order_id = ?
            ''', (order_id,))
            result = cursor.fetchone()
            return {
                'activation': result[0],
                'esim': result[1],
                'switch': result[2]
            }

    # Keep other existing methods...
======================

# ========== FIXED AGENT STATE DEFINITION ==========
class AgentState(TypedDict):
    order_id: str
    problem: str
    resolution: Annotated[str, "Resolution details"]
    next_step: Literal["resubmission", "esim", "switch", "human", "validation", "completed"]
    validation_result: Annotated[str, "Validation outcome"]
    retry_count: int

# ========== UPDATED MASTER AGENT ==========
def master_agent(state: AgentState):
    tools = TelecomTools()
    order_id = state["order_id"]
    
    try:
        status = tools.get_full_status(order_id)
        tools.log_fallout(order_id, "initial_detection")
        
        response = model.invoke(master_prompt.format(
            order_id=order_id,
            activation_status=status['activation'],
            esim_status=status['esim'],
            switch_status=status['switch']
        ))
        
        # Robust response parsing
        decision = "human"
        if 'Decision:' in response.content:
            decision_part = response.content.split('Decision:')[-1].strip().lower()
            decision = decision_part[1:-1] if decision_part.startswith('[') else decision_part
            decision = decision.split()[0]  # Take first word

        # Validate decision
        valid_steps = ["resubmission", "esim", "switch"]
        final_decision = decision if decision in valid_steps else "human"
        
        return {
            "next_step": final_decision,
            "problem": response.content,
            **state  # Preserve existing state keys
        }
        
    except Exception as e:
        print(f"Error in master agent: {e}")
        return {
            "next_step": "human",
            "problem": str(e),
            **state
        }

# ========== UPDATED TEST FUNCTION ==========
def run_test(order_id):
    print(f"\nProcessing order {order_id}:")
    initial_state = {
        "order_id": order_id,
        "problem": "",
        "resolution": "",
        "next_step": "",
        "validation_result": "",
        "retry_count": 0
    }
    
    for step in app.stream(initial_state):
        print(f"STEP: {step['next_step']}")
        print(f"STATE: {step}")
        print("-" * 40)
    
    print("="*50)
===================

# ========== ENHANCED MASTER AGENT ==========
def master_agent(state: AgentState):
    tools = TelecomTools()
    order_id = state.get("order_id", "")
    
    # Initialize default return values
    result = {
        "problem": "No analysis performed",
        "next_step": "human",
        **state  # Preserve existing state
    }
    
    try:
        if not order_id:
            raise ValueError("Missing order_id in state")

        # Get status with validation
        status = tools.get_full_status(order_id)
        if not all(status.values()):
            raise ValueError("Invalid status data")

        tools.log_fallout(order_id, "initial_detection")

        # Execute LLM analysis
        response = model.invoke(master_prompt.format(
            order_id=order_id,
            activation_status=status['activation'],
            esim_status=status['esim'],
            switch_status=status['switch']
        ))

        # Robust response parsing
        decision = "human"
        if response.content:
            # Use regex for reliable parsing
            import re
            match = re.search(r'\[(.*?)\]', response.content)
            if match:
                decision = match.group(1).strip().lower()
                
        # Validate decision against allowed steps
        valid_steps = {"resubmission", "esim", "switch"}
        final_decision = decision if decision in valid_steps else "human"

        return {
            "problem": response.content[:500],  # Truncate if needed
            "next_step": final_decision,
            **state
        }

    except Exception as e:
        print(f"Master Agent Error: {str(e)}")
        return {
            "problem": f"Error: {str(e)}",
            "next_step": "human",
            **state
        }

# ========== STATE VALIDATION ==========
def validate_state(state: dict) -> AgentState:
    """Ensure all required keys exist"""
    return {
        "order_id": state.get("order_id", ""),
        "problem": state.get("problem", ""),
        "resolution": state.get("resolution", ""),
        "next_step": state.get("next_step", "human"),
        "validation_result": state.get("validation_result", ""),
        "retry_count": state.get("retry_count", 0)
    }

# ========== UPDATED WORKFLOW SETUP ==========
workflow = StateGraph(AgentState)

def safe_master_agent(state: AgentState):
    return validate_state(master_agent(state))

workflow.add_node("master", safe_master_agent)
# Rest of workflow setup remains the same...
